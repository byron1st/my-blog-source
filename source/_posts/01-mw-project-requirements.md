---
title: '01. MW Project 제작기: 요구사항 분석'
tags:
  - Documentation
  - Requirements
categories:
  - SW-Development
  - SW-Engineering
date: 2016-08-14 20:48:44

---

[요구사항 온라인 문서 링크](https://github.com/byron1st/my-workshop-doc/blob/master/doc/req.md)

## 프로그램 제작 동기

MW Project는 MyWorkshop Project의 약자로, 내가 개인적으로 취미활동처럼 개발하기 시작한 프로그램이다. 시작은 프리랜서인 아내의 일을 도와주기 위해 시작한 개발이었는데, 구체적으로 뭘 어떻게 도와주는 프로그램을 만들어야 하는지 목표가 없다보니 계속 표류하였다. 덕분에 이것저것 공부는 많이 했다. Node.js도 접하고, JavaScript도 이 MW Project를 위한다는 명목(?)하에 즐겁게 공부했다. [DM4REVA](/dm4reva/index.html)도 원래는 Java로 개발하려 했었는데, MW Project를 위해 공부했던 내용을 써먹어보고 싶어서 JavaScript와 Electron으로 개발한 케이스다.<!--more-->

그렇게 JavaScript를 처음으로 제대로 공부하기 시작하고, Node.js와 Express, MongoDB(원래 MW Project는 서버-클라이언트 구조로 기획했었다.)를 거쳐 React, Electron까지 온게 벌써 9개월이다. 그 사이 3-4차례의 프로토타입과 [DM4REVA](/dm4reva/index.html)를 개발했고, 연구도 이제 논문만 쓰면 되는 단계까지 진행되었다 (혹은 그렇게 믿고 싶다). 이제 아내가 진담반농담반(?)으로 ’도대체 내 프로그램은 언제 만들어주는거야?!’라고 공격하는 상황이 되었으니, 한동안 즐겨하던 WoW 플레이 시간을 잠시 줄이고, 문명 6이 발매되기 전까지 취미활동 시간은 본 프로젝트에 투자하여 프로그램을 만들어야겠다고 생각했다.

## 요구사항 분석 필요성

1인 개발인데 요구사항 분석까지 할 필요가 있는가를 고민을 했었다. 하지만 몇차례 프로토타입을 만들어본 결과, 1인 개발임에도(혹은 1인 개발이기 때문에 더더욱) 요구사항 분석은 필요하다.

요구사항 분석은 내가 개발하려는 프로그램이 ’무엇’인지를 명확히 정의할 수 있도록 도와준다. 즉, 개발의 목표를 분명히 할 수 있다. 이를 바탕으로 마일스톤을 정할 수도 있고, 내가 이 프로그램을 통해 구체적으로 해결하려고 하는 문제점이 무엇인지를 정확히 알 수 있다. MW Project와 같은 1인 개발에는 클라이언트라던지, 개발을 지시한 상부가 없다. 그렇기 때문에, 스스로 그 목표를 명확히 하지 못하면, (내가 수차례 겪었던 다른 개발들처럼) 프로그램이 그냥 흐지부지 표류할 가능성이 크다. 누구한테 물어볼 사람이 없기 때문에, 더더욱 내 스스로 명확히 목표를 정해야 하고, 그렇기에 1인 개발에서도 요구사항 분석은 중요하다.

## 도구

나는 개인적인 개발을 수행할 때는 따로 워드프로세서를 써서 요구사항이나 설계를 기록하지는 않는다. 개인적으로 워드프로세서는 그런 것을 하기에는 썩 좋은 프로그램이라고 보진 않는다. 그보다는 스프레드시트 프로그램(Excel, Numbers, 또는 Google Spreadsheet)과 적당한 다이어그래밍 프로그램의 조합을 선호한다.

MW Project에서는 애플의 Numbers와 OmniGroup 사의 [OmniGraffle](https://www.omnigroup.com/omnigraffle)을 사용했다. 애플 플랫폼을 쓴다면 Numbers는 가볍게 쓰기 좋은 스프레드시트 프로그램이다. 특히 한 시트 내에서 여러 테이블을 독립적으로 사용할 수 있어 편리하다.(다른 스프레드시트 프로그램들(Excel, Google Spreadsheet)의 경우, 시트가 곧 하나의 큰 테이블이다.) 그리고 많은 사람들이 잘 모르지만, Numbers도 icloud.com을 통해 구글 문서(Google Docs)처럼 웹에서 접근하여 수정, 공유할 수 있다. 이는 Windows에서도 접근 및 수정 가능하다.

![Numbers에서 여러 독립적인 테이블을 한 시트 안에서 작성하는 모습](numbers-documentation.png)

OmniGraffle은 다이어그래밍, 와이어프래임(Wireframe) 모델링 등을 할 수 있는 그래픽 툴이다. 마이크로소프트의 Visio와 유사한 도구라고 보면 된다. OmniGraffle은 기본적으로 다이어그래밍보다는 와이어프래임 모델링에 촛점이 맞춰진 도구로서 Visio에 비해서는 그림을 그리는 자유도가 좀 더 높다.

## 요구사항 분석

MW Project의 첫 요구사항들은 내 아내의 요청과 나의 상상력에서 나온다. 뚜렷한 클라이언트가 존재하지 않는 프로그램이기 때문에, 열심히 초반에 상상력을 발휘해보는 것이 중요하다. 이 단계에서도 적당히 ID를 부여하여 스프레드시트에 기록해두면 좋을 것이다. MW Project는 규모가 크지 않기 때문에, 이러한 비즈니스 수준의 요구사항들은 몇가지 되지 않는다. 그래서 따로 기록을 하지 않고 바로 이 요구사항들을 기술적 수준의 요구사항들로 정제하는 작업으로 들어갔다.

요구사항은 크게 기능 요구사항(Functional requirement)과 품질 요구사항(Quality attribute 또는 Non-functional requirement)로 나누어진다. 여기에 제약사항(Constraint)을 포함하기도 하고, 더 나아가서는 이 제약사항을 ‘비즈니스 제약사항’, ’기술 제약사항’으로 나누기도 한다. MW Project는 작은 개인 개발 프로젝트이니, 복잡하게 가지 않도록 하자. 나는 필요에 따라 기능 요구사항과 품질 요구사항, 그리고 비즈니스 제약사항 정도 정의했다.

### 기능 요구사항

기능 요구사항을 표현하는 용도로 나는 UML 문법 중 하나인 [Use Case 다이어그램](http://www.uml-diagrams.org/use-case-diagrams.html)을 선호한다. 혹자는 UML의 Use Case를 기능 요구사항과 구분하기도 하지만, 나는 기능 요구사항을 표현하는데 사용되는 여러 방법들 중 하나로 여기는 것을 선호한다. ‘다이어그램’ 이라는 것 자체가 글로 작성하기에는 길고 혼잡한 것들을 정해진 문법에 따라 그림으로 시각화하여 한눈에 들어오게끔 해주는 용도다. 마찬가지로 Use Case 다이어그램은 ’_FR1: 사용자는 제품 정보를 수정할 수 있다_’와 같은 기능 요구사항을 아래 그림처럼 시각화해서 보여주는 좋은 방법이다.

![FR1을 Use Case 다이어그램으로 표현한 모습](usecase-example.png)

Use Case 다이어그램은 기능 요구사항 명세를 위해 필요한 기본적인 개념들을 아주 명료한 문법을 통해 표현해준다. 특히, Actor 개념을 통해 자연스럽게 각 기능들의 주체를 정의할 수 있게끔 유도하는 것은 아주 탁월한 문법적 장치이다. 또한, import, export 관계를 요구사항 단계에서 기초적인 모듈화를 표현할 수 있도록 해주는 것도 –가끔은 좀 과하다고 생각되지만– 잘 사용하면 설계 단계에서 큰 도움을 준다.

![MW Project의 Use Case 다이어그램. 색깔은 내가 개인적으로 버전 1(하얀색), 2(녹색), 3(청색), 그리고 향후 기회되면 추가할 기능들(회색)을 구분하여 표현한 것이다. 더 엄밀하게 정의하고 들어가자면, Use Case description을 통해 각 Use Case의 pre/post condition, execution flow도 정의해주어야 하지만, MW Project에는 엄밀하게 실행 순서를 검증해야 할 필요까지는 없으므로(대부분 아주 평범한 실행 순서를 갖는다), 생략하였다.](usecase-diagram-example.png)

### 품질 요구사항

흔히 Quality attribute 또는 Non-functional requirement라고 부르는데, 개인적으로는 Quality attribute[^1] 용어를 선호한다. 이 쪽이 용어가 의미하는 바가 무엇인지를 명확히 표현해주기 때문이다. 품질 요구사항은 시스템 전반에 걸쳐 영향을 미치는 품질에 대한 것을 정의한다. 대표적으로 ‘시스템 가용성(Availability)’, ‘성능(Performance)’ 등이 있다. 사실 이 이름들은 의미없고, 다 정의하기 나름이다. 나는 개인적으로 MW Project에서 다음 두가지 품질을 정의했다.

*   **시험용이성 (Testability)**: MW Project에서는 시험용이성을 “**UI 파트를 제외한 모듈들은 모두 독립적인 단위 테스트를 가진다**”로 정의한다. [DM4REVA](/dm4reva/index.html) 때도 그렇고, 이전에 프로토타입들을 개발할 때도, 시험을 제대로 자동화해놓지 못하면, 뭐 하나 바꿀 때마다 어디 다른데서 고장이 날까봐 겁에 질렸었다. 그래서 이번에는 정말 단위 테스트 정도는 반드시 자동화를 해놓고 가려고 한다. 이를 위해서는 단위 테스트가 시스템의 다른 부분에 영향을 주지 않고 독립적으로 잘 실행될 수 있도록 설계해야 한다.
*   **수정용이성 (Modifiability)**: MW Project에서는 수정용이성을 “**단순 기능 추가는 모듈 구조를 변경하지 않고, 관련 함수 추가만으로 가능해야 한다**”로 정의한다. 물론 이건 내 프로젝트 하에서만 통하는 정의다. 다른 시스템 개발에서는 같은 이름의 수정용이성이더라도 전혀 다른 정의를 갖는게 물론 가능하다.

### 비즈니스 제약사항

비즈니스 제약사항에는 흔히 예산, 시간 문제를 다룬다. 나에겐 시간이 제약사항이다. 10월 3일까지는 버전 1을 내놓아야한다.

## 프로젝트 관리와 관련된 기타 사항

소프트웨어 공학 수업에서는 이 부분을 원래 ‘프로젝트 계획(Project Planning)’ 단계의 일부로써 요구사항과 독립적으로 가르친다. 하지만 따로 글을 하나 파기엔 양이 많지 않으니, 기록의 목적을 달성하기 위해 본 문서의 꼬투리에나마 적어두도록 하겠다.

*   형상 관리
    *   버전관리 프로그램: Git. 메인 저장소는 내 개인 서버에 설치된 [GitLab](https://about.gitlab.com)으로 한다.
    *   브랜치 관리: [Git Flow](http://danielkummer.github.io/git-flow-cheatsheet/index.ko_KR.html) 기법에 따라 브랜치 관리를 하도록 한다. [SourceTree](https://www.sourcetreeapp.com)는 Git Flow용 UI를 제공해서 편리하다.
*   이슈 관리
    *   GitLab 내의 이슈 관리 프로그램을 쓰도록 한다.

## 참고사항

이 문서는 변경사항이 있을 경우, 지속적으로 업데이트 될 예정이다. 요구사항의 변경은 매우 비용이 많이 드는 치명적인 위험이지만, ’변화는 소프트웨어 삶의 본질[^2]’과도 같다. MW Project는 매우 작은 소프트웨어이고, 내가 혼자 모두 관리하는 프로젝트임에도 설계 중에도 수없이 변경이 있었고, 개발에 들어간 지금도 상세한 요구사항들은 여전히 변하고 있다. 그렇기에 어떤 종류의 소프트웨어 개발이라도, 변경은 반드시 존재할 수 있음을 기억하고 이를 손쉽게 추적, 변경할 수 있는 인프라를 갖추는 것은 매우 중요한 일이다. (내가 이러한 이유로 워드프로세서를 이용하는 것을 좋아하지 않는다. 워드프로세서는 변경 내역 추적이 아주 괴로운 프로그램이다.) 요구사항들에 ID를 부여하고, 이들 사이에 간단한 추적성 테이블을 기록해두는 것이 도움이 될 것이다.

* * *

[^1]: Carnegie Mellon University의 [Software Engineering Institute](http://www.sei.cmu.edu)에서 선호하는 용어다.
[^2]: I. Sommerville, _Software Engineering_, 8th Edition. Addition-Wesley, 2007\.