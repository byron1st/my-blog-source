---
title: JavaScript의 객체(Object)
tags:
  - JavaScript
categories:
  - SW-Development
  - Programming
date: 2016-04-23 14:46:49

---

## JavaScript에서 객체(Object)란?

Java를 주로 하던 내가 JavaScript를 공부할 때, JavaScript의 여러 개념들 중 가장 낯설었던 요소는 바로 '객체(Object)'였다. Java에서는 클래스의 정의에 따라 실행 중 생성되는 인스턴스들을 객체라고 불렀다. 그래서 UML 다이어그램에서 클래스 다이어그램이 정적인 관점의 시스템 구조를 표현한다면, 오브젝트 다이어그램은 동적인 관점의 시스템 구조를 표현하다고 말한다. 그렇기에 Java 언어의 개념에 익숙한 나는 클래스 개념 없이 객체를 생각하기 힘들었다.

<!--more-->

JavaScript가 구현하고 있는 최신 ECMAScript 2015(ECMA-262 6th Edition) 명세는 객체를 다음과 같이 정의한다.

> An object is a collection of properties and has a single prototype object. The prototype may be the null value.
> 
> (객체는 프로퍼티들의 컬렉션이며, 하나의 프로토타입 객체를 갖는다. 프로토타입 객체는 null 값을 가질 수 있다.)

그렇다면, 프로토타입은 무엇인가. 역시 동일한 명세를 참조하면 다음과 같다.

> (Prototype is) object that provides shared properties for other objects.
> 
> ((프로토타입은) 다른 객체들을 위한 공유 프로퍼티들을 제공하는 객체이다.)

잘 와닿지 않는다. 프로토타입에 대해 이야기하기 전에, 우선 객체에 대해 이해해보자.

JavaScript에서 객체는 프로퍼티들의 컬렉션이고, 프로퍼티는 고유의 키와 이에 대응하는 값으로 구성된다. 데이터 구조 중 맵(Java의 Hashtable [^1]을 생각해보자)으로 이해하면 쉽다. 즉, JavaScript에서 객체란 실행 시 특정 값들을 갖는(상태라고 볼 수도 있겠다.) 단위라고 볼 수 있다. 객체 자체를 이해하기 위해 Java에서의 객체의 정의도 한번 생각해보자.

JVM은 Java 프로그램을 실행시킬 때, 클래스 파일들을 읽어들인 후, 클래스의 정의(필드, 맴버 함수 등)를 static한 영역에 저장시킨다. 그리고 해당 클래스의 인스턴스들, 즉, 객체들을 생성하고 그들의 맴버 함수를 실행 시킬 때, static 영역에 저장되어 있는 클래스의 정의를 참조한다. 객체들이 실제 실행 시 갖고 있는 것은 그 객체 본인의 필드값들(또는 그 객체의 상태라고 볼 수 있겠다.) 뿐이다. 정리하면, 객체의 본질은 실행 시 특정 값들을 갖고 있는 작은 단위에 불과하다.

다시 JavaScript로 돌아오면, 다소 낯설게 느껴졌던 JavaScript의 객체 정의가 객체의 본질을 가장 미니멀하게 정의한 모습이라고 할 수 있겠다. 나는 JavaScript 객체 개념을 처음 봤을 때의 어색함을 이렇게 사고하여 이해했다.

## JavaScript 객체의 선언과 생성

그 개념을 이해했음에도 Java와 같은 객체 지향 언어에 익숙한 내가 JavaScript의 객체를 마주할 때는 아직 불편한 점이 좀 남아있었다. JavaScript의 객체는 그 객체의 종류를 규정할 수 있는 틀, 즉 클래스가 없다. 그렇기에 JavaScript에는 객체들의 맴버 변수들과 맴버 함수들을 정의하고, 이를 커스텀 타입으로써 재사용할 수 있는 엄격한 문법이 없고, 그렇기에 객체들은 객체라기보다는 숫자, 문자열 등을 담는 변수처럼 느껴진다. 바로 이러한 점이 나에겐 코드를 짤 때 미묘한 불안감을 주었다. 즉, 나에겐 내 코드의 구조를 어느정도 체계화 시키기 위해, 최소한의 클래스와 생성자가 필요했다. (Java 만 하던 사람의 본능 같은 걸까)

비록 엄격하게 제한하고 있지는 않지만, 분명 JavaScript에서도 코드 구조를 객체 지향 스타일로 최소한의 구조화를 할 수 있도록 제공하는 문법이 있다. 객체 선언 방법에는 여러가지가 있지만, 니콜라스 자카스의 책[^1]에 의하면, 아래 방법이 가장 일반적이고, 가장 먼저 고려해야 할 방법이라고 한다.

```js
function Person(name) {
  this.name = name;
}

Person.prototype = {
  constructor: Person,
  sayName: function () {
    alert(this.name);
  }
};

var John = new Person(‘John’);
John.sayName(); // John
```

여기서 `Person.prototype` 부분은 아래와 같이 해도 된다.

```js
Person.prototype.sayName = function () {
  alert(this.name);
}
```

여기서 눈여겨 볼 것들은 크게 다음과 같다.

*   `function Person(name)`: 생성자 함수이다. 일반적인 함수와 완전히 동일하며, 단지 차이는 `var John = new Person('John')`과 같이 `new` 키워드를 사용하여 호출되었다는 점 뿐이다. 만약 `new` 키워드를 이용하지 않고 호출한다면, 일반적인 함수와 완전히 동일하게 작동한다. 즉, 모든 함수는 `new` 키워드를 사용하여 호출한다면 모두 생성자 함수로 사용될 수 있다. `new` 키워드를 이용해 함수를 호출할 경우, JavaScript 인터프리터는 다음 작업을 수행한다.

    1.  객체를 생성한다.
    2.  생성자 함수의 `this` 값에 1에서 생성된 객체를 할당한다.
    3.  생성자 함수의 내부 코드를 실행한다. (위의 `this.name = name`이 있는 이유가 바로 이 부분 때문이다. 이 부분을 통해 1에서 생성된 객체에 프로퍼티들과 그들의 초기값을 추가된다.)
    4.  객체를 반환한다.

*   `Person.prototype`: 프로토타입 객체는 JavaScript를 객체 지향 언어로 만드는 매우 중요한 '객체'이다. JavaScript에서 모든 객체들은 프로토타입 객체를 참조한다. 심지어 프로토타입 객체 또한 `Object` 객체(미리 만들어져 있는 객체이다.)를 자신의 프로토타입 객체로 참조한다. 어떤 사람들은 프로토타입 객체를 참조하는 행위를 객체 지향 언어에서 '상속' 개념과 같다고 설명한다. 완전히 동일하지는 않지만, JavaScript에서 상속 개념을 구현할 때 프로토타입 객체를 이용하는 것은 사실이다.
    *   프로토타입 객체는 `constructor`라는 프로퍼티를 갖는데, 이는 생성자 함수를 참조한다. 생각하면 재밌는게, 생성자 함수는 객체이기 때문에* 프로토타입 객체를 참조하고, 이 참조된 프로토타입 객체의 `constructor` 프로퍼티는 자동으로 자신을 참조한 생성자 함수를 참조한다. 마치 상호 참조 같은 느낌이다.
    *   프로토타입 객체는 문자 그대로 '프로토타입'을 의미한다. 프로토타입이라는 단어 자체가 '제품이 이렇게 만들어질겁니다'라고 말해주는 예제같은 것이다. 프로토타입 객체는 자신을 참조하는 객체들이 '이런 프로퍼티들을 가지고 있을 것입니다'라고 말해주는 객체들의 프로토타입이다. 즉, 여기다가 적당히 프로퍼티들을 추가해주면, 이를 참조하는 모든 객체들은 해당 프로퍼티들을 공유한다. 예를 들어, 위의 예제처럼 함수를 프로토타입 객체의 프로퍼티로 추가해주면, 해당 함수는 마치 Java 클래스의 맴버 함수처럼 사용될 수 있다. (완전히 동일하지 않으니, 주의하자.)

*   `var John = new Person('John')`: `John`이라는 객체를 생성하는 부분으로, Java와 아주 유사한 문법이다. 이렇게 생성된 `John`이라는 객체는 다음과 같이 생겼다.

```js
John = {
  name: 'John',
  __proto__: Person // Firefox, Safari, Chrome
}
```

JavaScript는 객체의 프로퍼티를 읽을 때, 객체에 직접 정의된 프로퍼티들을 우선 검색하고, 그 후에 해당 객체가 참조하는 프로토타입 객체의 프로퍼티들을 검색하여 원하는 값을 찾는다.

(`__proto__` 프로퍼티는 엄밀히 말해서 JavaScript 표준 스팩은 아닌 것으로 알고 있다. 니콜라스 자카스 책에 의하면, 해당 프로퍼티는 파이어폭스, 사파리, 크롬에서 지원이 되며, 참조하는 프로토타입 객체를 개발자들이 명시적으로 접근할 수 있도록 한다. 하지만 이 프로퍼티를 지원하지 않는다고 해서 프로토타입 객체를 참조하지 않는건 아니다. JavaScript 내부에서는 참조하고 있다. 다만, 개발자들이 생성된 객체의 프로토타입 객체에 접근할 명시적인 방법이 없을 뿐이다.)

생성자 함수 객체, 프로토타입 객체, 생성된 객체들의 관계는 다음 그림이 아주 쉽게 잘 보여주고 있다.

![니콜라스 자카스 책의 228페이지 발췌](nicholas-snapshot.png)

`Person`은 생성자 함수 객체이다. 이 객체의 프로토타입 객체는 `Person Prototype` 객체이고 이 프로토타입 객체의 `constructor` 프로퍼티는 `Person` 객체를 참조하고 있다. `Person` 생성자 함수 객체를 `new` 키워드로 호출하여 생성한 `person1`, `person2` 객체의 [[Prototype]]은 인스턴스 내부에서 프로토타입 객체를 가리키는 포인터를 의미한다. 앞서 말한바와 같이 일부 브라우저는 `__proto__` 프로퍼티를 자동으로 생성하여 이 포인터에 접근할 수 있도록 해준다.

이 그림 상황에서 `person1.sayName()`을 호출할 경우, JavaScript 인터프리터는 우선 person1 객체 내부에 `sayName`이라는 프로퍼티가 있는지 찾는다. 없을 경우, [[Prototype]] 포인터를 따라가서 `Person Prototype` 객체 내부에서 `sayName` 프로퍼티를 찾아 실행한다.

생성자 함수 객체, 프로토타입 객체 개념을 잘 활용하면, JavaScript 에서도 객체 지향 개념을 활용하여 코드를 체계적으로 구조화 할 수 있다. 물론 완전히 동일하지 않기 때문에, 차이점을 잘 생각해가며 사용하는 것이 중요하다. 예를 들어, JavaScript에는 Overriding, Overloading 개념이 없으며, 이에 대한 차이점은 니콜라스 자카스 책의 6장을 참고하자.

* * *

[^1]: 니콜라스 자카스, 프론트엔드 개발자를 위한 자바스크립트 프로그래밍. 인사이트, 2013.