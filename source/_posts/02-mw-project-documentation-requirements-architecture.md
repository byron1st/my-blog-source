---
title: '02. MW Project 제작기: 요구사항과 아키텍처 문서화 이야기'
tags:
  - Documentation
  - Requirements
  - SW-Architecture
categories:
  - SW-Development
  - SW-Engineering
date: 2016-09-21 00:28:27

---

MW Project는 혼자 개발하는 작은 취미생활 프로젝트이지만, 그럼에도 불구하고 코드가 1천줄 넘어가기 시작하면 문서가 필요하다. 나는 예전에 연구에 사용할 1천줄 내외의 작은 프로그램을 짤 때도, 박스 & 라인 3-4개 정도로 구성된 최상위 수준 아키텍처 다이어그램은 그려놓고 프로그래밍을 했었다. 아마도 다이어그램으로 끄적끄적 구조화하는 것을 좋아하는 개인적인 성향 탓도 있을 것이다. MW Project는 그보다는 훨씬 큰 프로그램이기 때문에, 이번에는 좀 본격적으로 문서화를 준비해보았다.<!--more-->

원래 처음에는 워드프로세서를 이용하여 1-2개의 문서(아마도 요구사항 문서 1개, 아키텍처 문서 1개)로 관리하려고 했었다. 하지만 이내 워드프로세서는 다음과 같은 한계를 드러냈다.

*   **변경 추적이 어렵다**: 1개의 바이너리 문서로 관리되니, 변경점을 관리하기 어렵다. 이를 위해서 수동으로 직접 문서 초반에 ‘몇월 몇일 뭐 수정’ 이라고 적어둘 수도 있지만, 혼자하면서 그러고 싶지는 않다. 회사 공식 문서도 아니고…
*   **다이어그램 이미지 관리**: 나는 모든 다이어그램을 [OmniGraffle](https://www.omnigroup.com/omnigraffle)을 이용하여 그리고 이를 png 파일로 출력한다. 이를 워드프로세서에 삽입할 경우, 이미지 화질이 다운되기도 하고, 이미지 크기가 커질 경우 문서 파일의 증가로 렉을 유발하기도 한다. 또한 그 A4 용지 사이즈의 한계와 쪽 개념으로 인해 이미지 파일이 커지면 밑으로 튕겨버리거나 억지로 사이즈를 찌그러트리기도 한다. 가로로 길쭉한 이미지의 경우 특히 심하다. 또한, 이 이미지가 언제 출력된 이미지인지 관리가 힘들다. 물론 삽입 후 친절하게 문서 내에 써주면 되겠지만, 그런 불편함을 매번 반복하고 싶지는 않다.

워드프로세서 대신 내가 좋아하는 Markdown을 이용해서, 가볍게 텍스트 문서로 문서화를 할 수 있으면 참 편하겠다는 상상을 하게 되었다. 만약 그렇다면, Git을 이용해서 변경추적을 정말 용이하게 할 수 있을 것이고, 정확한 변경 사항과 함께 변경에 대한 간단한 코멘트도 커밋 메세지를 통해 남길 수 있을 것일테니 말이다. 이미지는 여전히 불편하겠지만, 적어도 이미지가 아애 파일 내로 임베드 되어버리는 워드프로세서보다는 변경 추적 및 관리가 편리할 것으로 보였다. (이미지가 변경되면, 이미지를 참조하는 부분의 링크 텍스트가 변경될 것이고, 이게 명확히 커밋 로그에 남을테니.) 그래서 선택한 문서화 방법은 다음과 같다.

*   변경 추적: Git
*   다이어그램 이미지 관리: `/images` 폴더에 몰아넣고 파일 이름에 다이어그램 ID, 생성 날짜를 기록한다.
*   문서 구성: 마치 소스코드처럼 최대한 여러 파일들로 쪼개어 모듈화한다. 이들 사이의 연결은 Markdown 문서의 링크를 통해 구성한다.

문서를 어디를 통해서 볼까를 고민했는데, 역시 제일 편한건 Markdown 파일만 올려놓으면 자동으로 파싱해서 보여주는 GitHub이었다. 그래서 GitHub에 my-workshop-doc 라는 프로젝트를 하나 개설하고 모든 Markdown 문서들을 푸시했다. 다이어그램 이미지와 문서 파일들의 경로는 상대 경로를 넣었다. (몰랐는데, GitHub이 상대 경로 정도는 잘 인식하여 링크를 생성해주었다.) 그 결과가 바로 아래 저장소이다.

[my-workshop-doc](https://github.com/byron1st/my-workshop-doc")

이 방법을 사용해서 문서를 기록하다보니, 다음과 같은 점들을 지원해주는 도구가 있다면 참 더없이 편하겠다는 생각이 든다.

*   문서 내의 링크를 상대 경로로 관리
*   각종 ID들(요구사항, 아키텍처 요소들, 다이어그램들 등)을 변수로 처리하여 이들의 추적성을 보장
*   Gulp 등의 빌드 도구를 이용하여 Microsoft Word, 한글 등으로 빌드. ([Scrivener](https://www.literatureandlatte.com/scrivener.php)의 compile 기능을 참고.)

언젠가 이런 보완점들을 지원할 수 있는 도구가 나오던지, 아니면 내가 개발할 기회가 생기던지 하기를 바란다.

그리고 무엇보다 좋은 점은 이 문서들을 Sublime Text에서 쓸 수 있다는 점이다!

## 문서 설명

[MW Project 요구사항, 아키텍처 문서 저장소](https://github.com/byron1st/my-workshop-doc)는 요구사항과 아키텍처 파트로 구성되어 있다. 소프트웨어 공학 이론에 따라 요구사항은 Functional Requirements (기능 요구사항), Quality Attributes (품질 요구사항 또는 비기능 요구사항), 그리고 Constraints (제약사항)으로 구성되어 있다. 아키텍처 문서는 우선 설계전략을 설명하고, 그 다음에 아키텍처 뷰 이론([IEEE 42010](http://www.iso-architecture.org/ieee-1471/ads/)의 ‘Architecture Viewpoints in an AD’ 섹션과 ‘Architecture Views in an AD’ 섹션 참고)에 따라 설계를 서술한다. 그리고 상세 설계, UI 설계를 서술하고 마지막으로 각 설계 요소들 사이의 추적성을 기록한 문서를 링크해두었다.

### 1\. 요구사항

#### 1.1\. 기능 요구사항

기능 요구사항은 (살짝 귀찮기도해서) 간단하게 UML Use case diagram을 올려두는 것으로 대신했다. UML Use case diagram은 프로그램의 기능을 사용자 관점에서 묘사하는 좋은 도구로, 소프트웨어 개발을 시작할 때 사용자의 요구사항을 구체화하는 좋은 도구이다.

#### 1.2\. 품질 요구사항

[MW Project 제작기 1편](http://byron1st.pe.kr/?p=773)에서 소개한 내용과 동일하게 작성했다. 사실 소프트웨어 공학 이론을 배운 사람이 품질 요구사항을 이렇게 작성하면 크게 혼난다.(;;) 개인 프로젝트라 ‘내가 이걸 중시할거다. 설계할 때 절대 까먹으면 안돼!!'라고 스스로 되새기기 위해 적어둔 수준이라 이렇게 간단하다. 나는 직업상 품질 요구사항 서술된걸 자주 채점하는데, 이건 나라도 점수 주기 힘든 수준의 서술이니 간단히 참조만하자.

### 2\. 설계

#### 1.1\. 설계전략

설계전략을 정의하는 것은 요구사항들을 만족시키기 위한 첫 삽을 푸는 작업과 같다. 설계전략을 크게 좌우하는 것은 바로 품질 요구사항이다. 기능 요구사항을 만족시키는건 큰 일이 아니다. 하지만 품질 요구사항은 프로그램을 ‘어떻게’ 구성해야 하는지를 좌우한다. 그렇기에 품질 요구사항을 만족시키는 것은 소프트웨어 설계의 핵심이다. 설계전략은 ‘요구사항들(특히 품질 요구사항들)을 만족시키기 위해서 우리가 어떻게 프로그램을 구성해야 할까?’ 라는 질문에 대한 ‘첫, 그리고 가장 추상적인 대답'이다. 내 문서의 [설계전략 부분](https://github.com/byron1st/my-workshop-doc/blob/master/doc/arch.strategies.md)은 그래서 근거에 품질 요구사항을 명시하고 있다. 이 설계전략은 바로 이 품질 요구사항을 만족시키기 위함임을 밝히는 것이다.

#### 1.2\. 아키텍처 설계

설계 부분은 아키텍처 뷰 이론을 기반으로 작성되었다. 아키텍처 뷰 이론은 좀 거칠게 말하자면, 소프트웨어 아키텍처를 다양한 관점에서 서술하는 것을 말한다. 즉, 예를 들면 소프트웨어 아키텍처를 사용 시나리오 관점에서 UML Sequence diagram 을 이용하여 묘사할 수도 있고, 모듈 관점에서 클래스들 사이의 import 관계로 묘사할 수 있다. 하나의 소프트웨어라도 그 구조를 묘사하기 위한 관점은 다양하게 존재할 수 있고, 이는 개발자(또는 아키텍트)가 보고자 하는 관심사항(이를 흔히 Stakeholder의 concerns라고 한다.)에 따라 정의된다.

아키텍처 뷰들의 종류는 정말 다양하고, 학자들에 따라 서로 다른 뷰들을 제시하기도 했다.[^1] 하지만 가장 중요한건, 진짜 필요한 아키텍처 뷰들만 잘 선정하여 문서화를 하고, 그를 통해 모든 품질 요구사항을 만족하는 프로그램을 만드는 것이다. 즉, 쓸데없는 뷰까지 묘사하느라 시간낭비를 해서는 안된다. 그리고 그걸 결정하는 것이 바로 소프트웨어 아키텍트의 역량이라고 할 수 있으며, 이는 다년간의 경험과 개발 도메인에 대한 학습을 통해 이루어진다.

나는 (다년간의 개발 경험이 있는건 아니지만) [DM4REVA](/dm4reva/index.html)를 포함한 4-5차례의 개인 Electron 프로젝트 개발 경험(실상은 삽질 경험)을 되살려 시나리오 뷰, 논리 뷰, 모듈 뷰, 코드 뷰, 실행 뷰 정도를 뽑았다.

순서는 언제나 시나리오에서 출발한다. 시나리오 뷰는 기능 요구사항의 Use case diagram과 밀접하게 관련이 있고, 어찌보면 Use case diagram에서 도출된 사용예들을 기술적 수준으로 구체화 시킨 모습이라고 볼 수 있다. 그리고 이 시나리오 뷰에서 도출된 아키텍처 요소들(한마디로, 박스들.)은 곧 논리뷰 요소들로 refactoring 되고, 이들은 실제 코드들의 집합이라고 정의할 수 있는 모듈로 refactoring 되어 모듈뷰에 나타나게 된다.

논리뷰와 모듈뷰는 상대적으로 추상적인 수준에서 각각 실행 시 소프트웨어 구조와 코드 관점에서의 소프트웨어 구조를 잡고 추상적인 아키텍처 요소들을 break-down 해 나간다. MW Project는 콩알만한(?) 프로젝트이니만큼 추상적인 설계는 2단계 정도만으로도 할게 없어진 수준이 되었다.

실행뷰와 코드뷰는 각각 실행 관점에서 실제 프로그램 요소들(스레드, 프로세스 등) 묘사하는 것이고, 코드뷰는 실제 코드 구조를 묘사한다. 즉, 상세 설계 직전의 아주 구체화된 모습이라고 볼 수 있다. 그리고 사실 코드뷰는 그림으로 그걸 그리기보다는 직접 코드 저장소를 열어서 폴더 구조를 잡는다거나, 코딩 규칙을 명시한다거나 하는 걸로 충분하다. 나는 ESLint라는 코딩 규칙을 명시하는걸로 대신했다.

그리고 내 문서를 보면 뜬금없이 DB 구조가 코드뷰 항목에 묘사되어 있는데, 새로운 뷰를 ([Rozanski 책](http://www.viewpoints-and-perspectives.info)에서는[^2] Information view라는 이름을 제안한다.) 만들까 고민하다가 (귀차니즘으로 인해) 코드뷰로 위치시켰다. 왜냐면 내가 이를 고민한 실제 시점이 그 때이기 때문이다. 근데 다른 곳으로 옮기는 것이 맞다. 사실 코드뷰의 정의와는 맞지 않는다. 이점을 참고하고 보시길 바란다.

#### 1.3\. 상세 설계와 UI 설계

상세 설계에서는 아키텍처 설계에서 짜둔 구조를 지키면서 그 안에서 진짜 코딩을 하는데 필요한 요소들을 정의해주어야 한다. 그래서 아키텍처 설계까지는 설계전략과 품질 요구사항이 막강한(?) 영향력을 행사하지만, 상세 설계 단계에서는 실제로 사용되는 구체적인 기술들이 더 큰 영향을 발휘한다. (여담이지만, 사실 어떤 기술을 사용할 것인지를 선택하는 것 자체도 아키텍처적인 결정이다. 그렇기 때문에 기술의 선택에서도 품질 요구사항과 설계전략을 고려해야 하며, 그 이유를 명확히 설명할 수 있어야 한다.)

그리고 상세 설계에서 무엇보다 중요한건 (다른 부분도 마찬가지지만) ‘필요한’ 부분만 잘 골라서 하는 것이다. 나는 혼자 개발하기 때문에 ‘스파게티 코드가 되지 않기 위해 내가 반드시 미리 정의해둬야 하는 것'들을 정의한다는 생각으로 작성했다. 안 그러면 코딩하는 중간에 '임기응변'식으로 작성하게되고, 결국 스파게티가 되버린 나의 프로그램을 마주하게 된다. 여럿이 개발할 때는 상세 설계에서 ’_우리가 서로 헛짓거리하지 않기 위해 미리 정해야 하는 것들이 무엇일까?_‘라는 질문을 끊임없이 던져가며 설계의 정도를 조절해야한다. 설계의 정도가 과하면 모든 애자일 개발자들이 싫어하는, 바로 문서를 위한 문서가 되어버린다. 또한, 이렇게 과도하게 자세한 상세 설계는 결국 코딩 단계에서 끊임없이 수정되게 된다. 이는 개발자들에게 계속 문서를 들락날락 거리게 만들어 개발자들을 질리게 만들거나, 아니면 문서가 버려진다.

나는 우선 아주 구체적인 (함수 콜 수준의) 실행 다이어그램을 몇개 정의했다. 이는 코드를 짜기 전에 미리 머릿속에서 시뮬레이션 해봄으로써 삽질을 줄이는데 있다. 코드를 몇시간 동안 짜놓고 더 좋은 방안이 생각나면 다 뒤집어 엎어야 하니, 그 전에 미리 실행 다이어그램을 통해 시뮬레이션을 좀 해보고 많이 고쳐보고 짜는 것이다.

##### 1.3.1\. Flux 아키텍처 스타일 설계 설계

이 프로젝트에서 Flux 아키텍처 스타일을 적용했다. 나는 이 아키텍처 스타일을 상당히 좋아하는데, 일단 그 구조가 정말 이해하기 쉽고, 관리하기 쉽다. Store와 Dispatcher 자체도 만약 고급 기능을 쓸 것이 아니고 예제 수준이라면 정말 손쉽게 구현할 수 있다.

```js dispatcher.js
class Dispatcher {
  constructor () {
    this.callbacks = {}
  }

  register (key, callback) {
    this.callbacks[key] = callback
  }

  dispatch (key, argument) {
    this.callbacks[key](argument)
  }
}

export default new Dispatcher()
```

예를 들어, 위 코드가 내가 사용하는 Dispatcher 코드의 전부이다. 몇가지 단점은 있지만[^3], 그래도 잘 작동한다. Facebook에서 제공하는 Dispatcher는 Action 사이의 의존 관계도 지원하는 등의 기능들로 인해 코드가 좀 더 길지만, 원리 자체는 위의 코드와 크게 다르지 않다. 그냥 미리 register 해놨다가 요청 들어오면 key 값에 따라 꺼내서 실행시키는 것 뿐이다.

Flux 아키텍처 스타일은 Action을 통해 Store를 업데이트 한다. 그리고 Store가 업데이트 되면, UI를 구성하는 최상위 React 컴포넌트의 State가 변하고, 이 변화가 UI를 변경한다. 이 구조를 미리 설계하기 위해 나는 다음 도구들을 썼다.

*   상태 다이어그램([UI 설계 문서](https://github.com/byron1st/my-workshop-doc/blob/master/doc/arch.ui.md)의 U01): UML State Diagram을 염두에 두고 그렸는데, 사실 야매 문법이다. 나의 목적은 이 다이어그램에서 UI의 상태들을 정의하고, 이 상태들 사이의 Transition을 정의한 후 이것들을 Action으로 구현하는 것이다. MW Project의 초기 버전에는 View, SubView, Edit 이라는 3개의 상태가 있다. 그리고 이들의 상태는 A0-A8로 명시된 Transition을 통해 변화된다.
*   Transition과 Action의 매핑([상세 설계 문서](https://github.com/byron1st/my-workshop-doc/blob/master/doc/arch.detail.md)의 Action들 정의 문서): 상태 다이어그램에서 정의된 Transition들을 작동시키는 Action들을 정의하였다. Action들의 정의는 기본적으로 Action 이름과 파라미터 정의를 의미한다. IPC 연결을 요구하는 Action들은 따로 분류했다.

##### 1.3.2\. React 컴포넌트 설계

React 컴포넌트는 UI를 구조화할 수 있도록 도와주는 기술이다. 그렇기 때문에, React 기술을 사용하기로 했을 때, 가장 중요한 설계는 ‘어떤 UI 컴포넌트들이 있는지’ 재사용 관점에서 식별하고, 이들 사이의 포함관계를 정의해두는 것이다. 나같이 혼자 개발할 때도 중요하지만, 여럿이 개발한다면 이를 미리 다이어그램으로 묘사해서 명시해두는 것은 매우 중요하다. 안그러면 진짜 스파게티 구조의 끝판왕을 볼 수 있다.

특히 ‘재사용 관점'에서 UI 컴포넌트들을 식별하는 것은 중요하다. 이를 고려하지 않으면, 그냥 HTML 코드를 JavaScript 클래스로 감쌌다는 것 외에는 아무런 차이가 없다. 모든 UI 부분들에 대해 따로 따로 모두 React 클래스가 존재한다면, 이를 클래스화 하는 것이 그냥 HTML 파일에 적는 것과 무슨 차이가 있겠는가. (유지보수 관점에서 해당 코드를 찾기에는 좋을지 모르겠다.) 바로 내 [DM4REVA](/dm4reva/index.html)의 React 컴포넌트가 그 모양 그 꼴이다. 반면교사로 삼으면 될 듯 하다.(흑흑) UI 컴포넌트에서 '파라미터화 될 수 있는’ 것들이 어떤 것들인지 살펴보고 UI 요소들을 React 클래스로 구조화하는 것이 필요하다. 역시 이 또한 다년간의 경험이 쌓인 숙련된 Front-end 아키텍트가 가능한 일일 것이다.

UI의 어떤 변수들을 State로 정의 할 것이고, Props로 정의 할 것인지도 중요한 요소지만, Flux 아키텍처의 경우 Store를 통해 모든 것을 관리하므로 (정확히는 최상위 React 컴포넌트에만 Store의 요소들이 State로 들어가고, 나머지는 모두 Props로 전달.) 크게 중요하지 않다.

##### 1.3.3\. Electron 앱 구조 설계

Electron 앱들은 사실 잘 생각해보면, 그냥 전형적인 Client-Server 아키텍처 스타일을 갖는 소프트웨어들이다. Renderer 프로세스들이 Client 역할을 하고 Main 프로세스가 Server 역할을 한다. 이벤트 채널 형태로 등록되는 IPC 들은 사실 HTTP를 통한 API 콜과 유사하다. 여기에 본인은 Main 프로세스에 임베드 DB까지 붙였으니, 정말 영락없는 Client-Server 아키텍처 스타일을 갖게 되었다. 그래서 이 경우, Main 프로세스에서 IPC 채널을 통해 제공될 API 함수들을 잘 정의해놓고 이들이 DB 함수들과 어떻게 연결될지를 잘 정의해두는것이 중요하다.

## 설계 Summary

이로서 어느정도 설계가 끝났다. 하지만 설계에는 사실 ‘종료'라는 것이 없다. 설계와 코딩은 끊임없이 서로 반복되는 과정이다. 초기에는 설계 90, 코딩 10 되던게 막바지 되서는 설계 10, 코딩 90이 될 수는 있어도, 설계가 완전히 끝나고 코딩에만 집중하게 되는, 그런 행복한 일은 존재하지 않는다.(개발 한복판에 요구사항도 변경되는 일이 빈번한 마당에…) 만약 그런 개발이 존재한다면, 그건 둘 중 하나다. 1) 설계가 정말 정말 단순해서 '우린 MVC 스타일을 따른다. 끝!’ 수준이다. 2) 설계 문서의 내용은 코딩 수준에서 이미 모조리 변경되서 쓸모 없어져 버렸다. 그 문서는 아무도 보지 않는다. 부장님 빼곤.

그렇기 때문에 설계 문서를 위한 인프라를 구축할 때는 1) 언제나 편하게 열람할 수 있는지, 2) 언제나 편하게 수정할 수 있는지, 3) 변경 내용에 대해 손쉽게 토의하고 이를 반영할 수 있는지를 고려해야 한다.[^4] 그래야만 문서를 위한 문서, CMMI 등급을 받기 위한 문서에 머무르지 않고 진짜 도움이 되는 문서가 될 수 있을 것이다. 하지만 회사 특성상 그게 쉽지 않을 것이다. 회사는 회사 고유의 프로세스가 있고 문서 규정이 있으니 말이다. (우린 아마 안될꺼야… 흑흑)

그리고 아직 한참 개발 중이지만, 일단 현재까지 개발한 부분까지 아래 저장소에 올려놓았다. 아직 제대로 작동하지는 않지만, 아키텍처 문서와 실제 구현을 비교해가며 참고하기에 좋을 것으로 보여 급하게 나마 올려보았다.

[my-workshop](https://github.com/byron1st/my-workshop/tree/develop)

## 아키텍처 문서화에 대한 개인적인 생각

문서화는 사실 지루한 작업일 수 있다. 나같은 경우, 코딩보다도 아키텍처를 그리고 문서화하는걸 더 좋아하는 특이체질이지만, 대부분의 개발자들은 그렇지 않을것이다. 많은 사람들이 아키텍처에 대해 오해하고 있지만, 사실 아키텍처의 문서화의 포인트는 바로 ‘필요한만큼'만 하는 것에 달려있다. 그리고 (이건 내 생각이지만) 그 '필요한만큼'이 어느정도인지를 파악할 수 있는 사람이 바로 '소프트웨어 아키텍트'이지, 무슨 UML 좀 알고 아키텍처 이론을 아는 사람들이 아키텍트는 아니다.

하지만 그렇다고 이론을 아는 것을 등한시하면 안된다. 이론을 아는 것은 아주 중요하다. 이론을 모르면 요구사항을 만족시키기 위한 좋은 아키텍처들이 자기 머릿속에만 있고, 이것을 같이 일하는 다른 개발자들에게 효과적으로 전달하지 못한다. 이론이라는 것은 지식을 표현하기 위한 정형화된 좋은 틀을 제공해준다. 이 틀에 맞춰서 자신의 지식을 전달하면, 적어도 이 틀을 알고 있는 사람들은 그 지식을 전달 받을 수 있다. 하지만, 아키텍트에 준하는 경험과 능력을 갖고 있는 사람이라도, 이 틀을 모른다면 그 지식을 표현할 수 없고, 결국 알아듣지 못하는 아랫사람들의 능력 부족만 탓하게 된다. 그런 의미에서 아키텍처 이론과 도구를 배우는 것은 아키텍트의 역량 만큼이나 중요하다.

---

[^1]: 아키텍처 뷰 이론을 처음 주장한 P.Krutchen은 4개의 뷰와 이들을 묶어주는 시나리오 뷰로 구성된 4+1 뷰를 제안했다.(P.Krutchen이 당시 Rational 사 직원이었기 때문에, 4+1 뷰를 Rational 사의 것으로 알려져 있는 경우도 있다. 현재는 캐나다에서 교수를 하고 있다.) 소프트웨어 공학으로 저명한 미국의 카네기 멜론 대학교의 Software Engineering Institute(SEI)는 실행 관점의 C&amp;C 뷰, 코드 관점의 모듈 뷰, 그리고 배치 뷰로 구성된 3개의 뷰 이론을 제시하기도 했다. 그 외에도 수없이 많은 제안들이 있다. 언제 한번 따로 글을 쓸 기회가 있길 바란다.
[^2]: 국내에 번역본도 있다. 아주 실용적이면서 좋은 책이고, 아주 훌륭한 분이 번역한 책이니 관심있는 분들은 참고하시길.
[^3]: argument를 1개만 받을 수 있고 (근데 뭐, JavaScript에서는 그냥 argument를 오브젝트로 넘겨주면 사실상 제약이 없다.) 견고하지 못하다. 만약 여럿이 개발하는 프로젝트라면, 자칫 대재앙이 벌어질 수 있다. 그래서 이를 보완하기 위해 개별 Action 쪽 코드가 비대해진다.
[^4]: Git과 Git 기반의 이슈 관리 시스템을 문서 관리 인프라로 구축하는 것은 꽤 괜찮은 아이디어가 될 수 있다. 모두 텍스트 기반 문서이기 때문에 탐색이 아주 쉽고, 변경 추적이 아주 쉬우며, 커밋 메세지를 통해 문서 변경점을 요약해줄 수도 있고, 코드 리뷰 기능이나 이슈 기능을 통해 문서 내용에 대한 논의를 진행/기록할 수 있다. 이것들을 적절히 회사 규정에 맞는 워드 문서로 빌드해주는 빌드 도구만 만들어준다면…!!